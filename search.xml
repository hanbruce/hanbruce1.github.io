<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[从Git到Github个人博客]]></title>
      <url>%2F2017%2F02%2F18%2Fgit-detail%2F</url>
      <content type="text"><![CDATA[本教程软件运行的环境为：windows7 Git 安装. git安装Git安装包下载地址运行exe,一路Next，完成安装后在Git Bash中输入以下命令，检验是否安装成功 git –version 成功的如下图：. 用户配置 git config –global user.name “your name” git config –global user.email “your email” . 查看配置信息输入以下命令，检验受否配置成功 git config –list GithubGithub地址：https://github.com/ 注册Github账号依次填入个人：昵称、邮箱、密码，然后点击”Sign up for Github”。注意，去邮箱验证Github发送的验证邮件。 个人账号属性推荐勾选free，然后选择Finish sign up。能免费干嘛要付费，反正我又没啥秘密，不介意，你随便看看…… ssh key在Git Bash中输入以下命令，生成ssh key. ssh-key -t rsa -C “your email” 成功的话会在~/下生成.ssh文件夹，进去，打开 id_rsa.pub，复制里面的 key。 add ssh key 点击图标右边三角形选择setting单击”SSH and GPG keys“,选择”New SSH key“添加成功之后的界面 验证是否成功输入以下命令： ssh -T git@github.comHi hanbruce! You’ve successfully authenticated, but GitHub does not provide shell access. 看到“ Hi hanbruce! You’ve successfully authenticated“表明已经成功了，后面的直接略过……git就到这里了，后面会写一篇博文专门讲解Git。 Git个人博客折腾那么多，不炫一下好意思，赠送一个有逼格的个人博客，请往下看： . Node安装Node下载地址：https://nodejs.org/en/运行exe，一路Next,完成安装。在CMD中输入以下命令，检查是否安装成功： . Hexo安装在D盘中，新建一个文件夹Hexo，当然你可以在喜欢的任意的地方创建。在CMD中输入以下命令，安装Hexo： npm install hexo-cli -g 接着你会看到下图：这个不影响使用，直接输入以下命令：1npm install hexo --save 在CMD中输入以下命令，输入：1hexo -v 出现下图，即为成功。 Hexo 配置 初始化配置： 1hexo init 安装组件 1npm install 体验Hexo 马上就可以见证奇迹了，哈皮啦！1hexo s 我靠，说好的简洁优雅的个人博客了，此地空余懵逼的我！冏！ 坑爹的Foxit!!!装有Foxit PDF阅读器会占用4000端口，与hexo默认4000端口相互冲突，请注意修改端口，使用如下命令： 1hexo s -p 5000 在浏览器中打开http://localhost:4000/，你将会看到： Hexo主题设置从个人喜好的角度出发，强烈推荐使用简洁优雅的Next主题，让我们开启Next主题……. 克隆主题在cmd下，切换到Hexo站点目录下，输入以下命令： 1git clone https://github.com/iissnan/hexo-theme-next themes/next . 启用主题在Hexo文件下，找到站点配置文件_config.yaml，修改theme主题为next即可。1theme next . 验证主题在cmd下，输入以下命令：1hexo s -p 5000 观察命令行输出提示：12INFO Start processingINFO Hexo is running at http://localhost:5000/. Press Ctr+C to Stop. 在浏览器中访问： http://localhost:5000 ，你将看到一下，Next默认的Scheme —— Muse。 Hexo与Github page关联只在本地玩，不推到Github上怎么好意思。。。. 建立repo 然后填写域名，选择public，最后Create repository！ . 配置Deployment在站点配置_config.yml文件中，找到Deployment，然后按照如下修改 12345deploy: type: git repo: https://github.com/hanbruce/hanbruce.github.io.git // https://github.com/your name/your repo.git branch: master . 安装拓展1npm install hexo-deployer-git --save . 将hexo推送到github hexo d -g若此时出现如下问题： 将站点配置_config.yml文件中找到Deployment，改为：1234deploy: type: git repo: https://github.com/hanbruce/hanbruce.github.io.git branch: master 我的个人博客地址 好了，终于完成了，默默的喝上铁观音……撤了！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Socket，开发那些事……]]></title>
      <url>%2F2017%2F02%2F10%2FSocket%2F</url>
      <content type="text"><![CDATA[TCP/IP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket,从而在通信的两端之间形成网络虚拟链路。一旦建立了虚拟网络链路，两端的程序就可以通过虚拟链路进行通信。Java对于TCP协议的网络通信提供了良好的封装，Java使用Socket对象来达标两端的通信端口，并通过Socket产生IO流来进行网络通信。 ServerSocketSocket accept():如果接收到一个客户端Socket的连接请求，该方法将返回一个与客户端Socket对应的Socket；否则该方法将一直处于等待状态。ServerSocket(int port):用来指定的端口port（0~65535）来创建一个ServerSocket。1234567//创建一个ServerSocket，用于监听客户端的Socket的连接请求ServerSocket mServerSocket= new ServerSocket(3000);//采用循环不断地接收来自客户端的请求while (true)&#123;//每当接收到客户端Socket的请求时，服务端也对应产生一个SocketSocket mSocket=mServerSocket.accept();&#125; Socket Socket(InetAddress/Sting remoteAddress,int port):创建连接到指定远程主机、远程端口的Socket 12//创建连接到本机、3000端口的SocketSocket mSocket= new Socket(&quot;127.0.0.1&quot;,3000); IO流InputStream getInputStream():返回该Socket对象对应的输入流，让程序通过该输入流从Socket中取出数据OutputStream getOutputStream():返回该Socket对象对应的输出流，让程序通过该输入流从Socket中取出数据 服务端：1234567891011//创建一个ServerSocket，用于监听客户端的Socket的连接请求ServerSocket mServerSocket= new ServerSocket(3000)；while(true)&#123;//每当结束到客户端Socket的请求时，服务端也对应产生一个SoketSocket mSocket=mServerSocket.accept();//将Socket对饮的输出流包装成PrintStreamPrintStream ps=new PrintStream(mSocket.getInputStream());ps.println(&quot;this is testing!&quot;);ps.close();mSocket.close();&#125; 客户端： 1234567Socket mSocket=new Socket(&quot;127.0.0.1&quot; ,3000);BufferedReader br = new BufferedReader(new InputStreamReader(mSocket.getInputStream());//进行普通IO操作String line = br.readLine();System.out.println(&quot;来自服务端的数据:&quot;+line);br.close();mSocket.close(); SocketClient&amp;SocketServer将socket客户端封装成SocketClient类，并提供connect(ip,port)、send()方法，通过接口类SocketListener来回掉onReceive( msg)、onSend()接收发送的信息。关键代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /** * 连接服务端 * @param serverIp * @param serverPort */ public void connect(final String serverIp, final int serverPort) &#123; // 开启一个线程启动tcp socket new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; byte[] buffer; String msg; mSocket = new Socket(serverIp, serverPort); InputStream inStream = mSocket.getInputStream(); in = new BufferedReader(new InputStreamReader(mSocket.getInputStream())); out = new PrintWriter(new BufferedWriter(new OutputStreamWriter( mSocket.getOutputStream())), true); while (true) &#123; buffer = new byte[512]; if (mSocket.isConnected()) &#123; if (!mSocket.isInputShutdown()) &#123;// if ((content = in.readLine()) != null) &#123;// content += &quot;\n&quot;;// if (mSocketListener != null)// mSocketListener.onReceive(content);// &#125; if (inStream.read(buffer) != 0) &#123; msg = new String(buffer, &quot;UTF-8&quot;).trim(); if (mSocketListener != null) mSocketListener.onReceive(msg); &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; 将socket服务端封装成SocketServer类，并提供startServerSocket(serverPort)，通过接口类SocketListener来回掉onReceive( msg)、onSend()接收发送的信息。关键代码如下： 123456789101112131415161718192021222324252627public void startServerSocket(final int serverPort) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; mServerSocket = new ServerSocket(serverPort); mExecutorService = Executors.newCachedThreadPool(); while (true) &#123; socket = mServerSocket.accept(); mExecutorService.execute(new ReceiveThread(socket)); System.out.println(&quot;----connected success----&quot;); &#125; &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(&quot;UnknownHostException--&gt;&quot; + e.toString()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(&quot;IOException&quot; + e.toString()); &#125; &#125; &#125;).start(); &#125; Demo地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown基本语法讲义]]></title>
      <url>%2F2017%2F02%2F08%2FMarkdown%2F</url>
      <content type="text"><![CDATA[此文作为Markdown语法收录，后续持续更新 标题123456# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题二级标题三级标题四级标题五级标题六级标题字体1粗体：**粗体** 斜体：*斜体* 粗体 斜体 超链接12website:[](url)picture:![alt ](url &quot;Title&quot;) 掘金 列表123456789无序列表：- aaaaaaaaaaaaa- bbbbbbbbbbb- cccccccccccccc有序列表：1. 111111111112. 2222222222223. 3333333333 aaaaaaaaaaaaa bbbbbbbbbbb cccccccccccccc 11111111111 222222222222 3333333333 引用本文主旨教你学会使用MarkDown来写文章。 代码块12RuleCommon rulecommon = new RuleCommon();int ipersonIDLogin = JobUser.GetPersonIDFromCookie(); 标记1&gt; text Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 表格1234567A|B|C---|------|------------1| sogou| Sogou2| baidu | BaiDu搜索引擎3|google | Google搜索引擎4|China|中国5|USA|美国 A B C 1 sogou Sogou 2 baidu BaiDu搜索引擎 3 google Google搜索引擎 4 China 中国 5 USA 美国]]></content>
    </entry>

    
  
  
</search>
